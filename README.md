#  Operation-System-Experiment

武汉大学软件工程操作系统课程设计

主要是使用高级语言模拟操作系统管理的一些算法，整体难度不大，甚至感觉像是在做数据结构的作业。

第一次实验课写了两个实验，分别是

1，模拟处理器调度算法中的按优先数调度算法

2，模拟可变分区管理方式下采用首次适应算法实现主存分配和回收

### OS_exp1

实验要求如下：

***\*(1)假定系统有5个进程，每个进程用一个PCB来代表。PCB的结构为：\****

***\*·进程名——如P1~P5。\****

***\*·指针——按优先数的大小把5个进程连成队列，用指针指出下一个进程PCB的首地址。\****

***\*·要求运行时间——假设进程需要运行的单位时间数。\****

***\*·优先数——赋予进程的优先数，调度时总是选取优先数大的进程先执行。\****

***\*·状态——假设两种状态：就绪和结束，用R表示就绪，用E表示结束。初始状态都为就绪状态。\****

***\*(2)\**** ***\*开始运行之前，为每个进程确定它的“优先数”和“要求运行时间”。通过键盘输入这些参数。\****

***\*(3)\**** ***\*处理器总是选择队首进程运行。采用动态改变优先数的办法，进程每运行1次，优先数减1，要求运行时间减1。\****

***\*(4)\**** ***\*进程运行一次后，若要求运行时间不等于0，则将它加入就绪队列，否则，将状态改为“结束”，退出就绪队列。\****

***\*(5)\**** ***\*若就绪队列为空，结束，否则转到\*******\*(3)\*******\*重复。\****

用java写的，核心算法一个排序

每次执行让进程优先数和运行时间-1，再重新排序，执行优先数最大的进程。

直到所有进程要求运行时间全为0

写的可能不是很规范，建了一个OperationSystem类，在其中定义了一些静态方法，对PCB类进行操作。

运行效果如下：

模拟设置了五个线程，分别让用户输入线程优先数

![lhET4SIuYMHaUZg](https://i.loli.net/2021/05/15/lhET4SIuYMHaUZg.png)

输入完成后会自动输出表格显示信息，并将第一次按优先数进行排序的表显示出来

然后依次执行，每执行会本次执行的进程的进程名，并将新的表格输出。

输入完成后初始表和排序表：

![oPXN45gmZVkeqt7](https://i.loli.net/2021/05/15/oPXN45gmZVkeqt7.png)

运行过程：

![v5NEY7n28oRerCA](https://i.loli.net/2021/05/15/v5NEY7n28oRerCA.png)

中间过程还是比较长的，最后所有要求运行时间全0，退出：

![Rfd4baMXTtp2UcS](https://i.loli.net/2021/05/15/Rfd4baMXTtp2UcS.png)



### OS_exp2

实验要求：

**(1)** ***\*可变分区方式是按作业需要的主存空间大小来分割分区的。当要装入一个作业时，根据作业需要的主存容量查看是否有足够的空闲空间，若有，则按需分配，否则，作业无法装入。假定内存大小为128K，空闲区说明表格式为：\****

***\*·分区号——表示是第几个空闲分区；\****

***\*·起始地址——指出空闲区的起始地址；\****

***\*·长度——一个连续空闲区的长度；\****

**(2)** ***\*采用首次适应算法分配回收内存空间。运行时，输入一系列分配请求和回收请求。\****

***\*要求能接受来自键盘的空间申请及释放请求，能显示\*******\*分区分配及回收后的内存布局情况。\****



分配很容易，就是按顺序找到第一个空间大于申请空间的分区，然后分配给他

回收算法如下需要考虑几种情况：

1，回收分区起始地址和空闲分区相邻，但和后面空闲分区不相邻，则将回收分区和前面相邻的合并，起始地址为前面空闲分区起始地址

2，回收分区起始地址和前面空闲分区不相邻，和后面分区相邻，则与后面分区合并，起始地址为回收分区起始地址

3，回收分区和前，后空闲分区都不相邻，则新建一个表项

4，回收分区和前后空闲分区都相邻，则将3块分区合并，其实地址为第一块空闲分区起始地址

运行截图如下：

请求内存：

![r9EoUSB45NfusTI](https://i.loli.net/2021/05/15/r9EoUSB45NfusTI.png)

回收内存：

![Miw5zj6dRP1T7IK](https://i.loli.net/2021/05/15/Miw5zj6dRP1T7IK.png)

回收分区恰好与前后空闲分区相邻，所以1号分区，回收分区，和2号分区直接合并成一块分区，编号为1，其实地址为1号分区起始地址50，大小为20+30+10 = 60



### OS_exp2_new

***\*在分页管理方式下采用位示图来表示主存分配情况，实现主存分配和回收\****

***\*[提示]：\****

**(1)** ***\*假定系统的主存被分成大小相等的64个块，用0/1对应空闲/占用。\****

**(2)** ***\*当要装入一个作业时，根据作业对主存的需求量，先查空闲块数是否能满足作业要求，若能满足，则查位示图，修改位示图和空闲块数。位置与块号的对应关系为：\****

***\*块号=\*******\*j\*8+i\*******\*，其中\*******\*i\*******\*表示位，\*******\*j\*******\*表示字节。\****

***\*根据分配的块号建立页表。页表包括两项：页号和块号。\****

**(3)** ***\*回收时，修改位示图和空闲块数。\****

***\*要求能接受来自键盘的空间申请及释放请求，能显示\*******\*位示图和空闲块数的变化，能显示进程的页表。\****

由于实验三选用了可变分区管理方式，验收的时候实验二有点问题，所以实验二重新选了分页管理方式

在验收的时候，老师专门要求提高鲁棒性，第一遍没有通过，,又修改了一部分才完成



运行截图如下：

<img src="https://i.loli.net/2021/05/21/lzohXU5IQEfKL2r.png" style="zoom: 33%;" />

<img src="https://i.loli.net/2021/05/21/vBGncHzDgOKTR62.png" style="zoom: 50%;" />

<img src="https://i.loli.net/2021/05/21/xCzQwmiyc3Hp4KX.png" style="zoom: 33%;" />

<img src="https://i.loli.net/2021/05/22/nLIqjtV8iSuBpea.png" alt="43F20478D236CE7392057FDA7B5C55CA" style="zoom: 50%;" />
